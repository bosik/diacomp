Вариант асинхронной авторизации

	/**
	 * Attempts to authenticate the user credentials on the server.
	 * 
	 * @param username
	 *            The user's name
	 * @param password
	 *            The user's password to be authenticated
	 * @param handler
	 *            The main UI thread's handler instance.
	 * @param context
	 *            The caller Activity's context
	 * @return Thread The thread on which the network mOperations are executed.
	 */
	/*
	 * public Thread backgroundAuth(final String username, final String password, final Handler
	 * handler, final Context context) { final Runnable runnable = new Runnable() { public void
	 * run() { login(username, password, handler, context); } }; // run on background thread. return
	 * performOnBackgroundThread(runnable); }
	 */
	 
Тестирование функции получения времени сервера

	Date localTime1 = Calendar.getInstance().getTime();
	long serverTime1 = web.timeShift;

	try
	{
		Thread.sleep(3000);
	} catch (InterruptedException e)
	{
	}

	Date localTime2 = Calendar.getInstance().getTime();
	long serverTime2 = web.timeShift;

	long d1 = localTime1.getTime() - serverTime1;
	long d2 = localTime2.getTime() - serverTime2;
	long diff = Math.abs(d1 - d2);

	Log.d(TAG, "diff: " + String.valueOf(diff));

	assertTrue(diff < MAX_DIFF);

При конструировании потомков всегда вызывается родительский конструктор

	public static class Father
	{
		public Father()
		{
			Log.e(TAG, "Father's constructor");
		}
		
		public void test()
		{
			Log.e(TAG, "Father test!");
		}
	}
	
	public static class Son extends Father
	{
		public Son()
		{
			super(); // эта строчка не влияет на вывод
			Log.e(TAG, "Son's constructor");
		}
		
		public void test()
		{
			Log.e(TAG, "Son test!");
		}
	}
	
	public void testInheritance()
	{
		Son son = new Son();
		son.test();
	}
	
	Вывод:
		Father's constructor
		Son's constructor
		Son test!